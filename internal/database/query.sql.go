// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :execrows
UPDATE friendships
    SET
        status = 'accepted',
        responded_at = NOW()
    WHERE
        user_a_id = LEAST($1, $2) AND
        user_b_id = GREATEST($1, $2)
`

type AcceptFriendRequestParams struct {
	UserAID   uuid.UUID
	UserAID_2 uuid.UUID
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, arg AcceptFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, acceptFriendRequest, arg.UserAID, arg.UserAID_2)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createFriendRequest = `-- name: CreateFriendRequest :exec
INSERT INTO friendships (user_a_id, user_b_id, requester_id)
VALUES (LEAST($1, $2), GREATEST($1, $2), $3)
`

type CreateFriendRequestParams struct {
	Column1     interface{}
	Column2     interface{}
	RequesterID uuid.UUID
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) error {
	_, err := q.db.Exec(ctx, createFriendRequest, arg.Column1, arg.Column2, arg.RequesterID)
	return err
}

const createMonthlyPlaylist = `-- name: CreateMonthlyPlaylist :one
INSERT INTO monthly_playlists(user_id, tracks, year, month, name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateMonthlyPlaylistParams struct {
	UserID uuid.UUID
	Tracks [][]byte
	Year   int16
	Month  int16
	Name   string
}

func (q *Queries) CreateMonthlyPlaylist(ctx context.Context, arg CreateMonthlyPlaylistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createMonthlyPlaylist,
		arg.UserID,
		arg.Tracks,
		arg.Year,
		arg.Month,
		arg.Name,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getLatestPrivateKey = `-- name: GetLatestPrivateKey :one
SELECT kid, value FROM private_keys
ORDER BY kid DESC
LIMIT 1
`

func (q *Queries) GetLatestPrivateKey(ctx context.Context) (PrivateKey, error) {
	row := q.db.QueryRow(ctx, getLatestPrivateKey)
	var i PrivateKey
	err := row.Scan(&i.Kid, &i.Value)
	return i, err
}

const getPlaylist = `-- name: GetPlaylist :one
SELECT id, user_id, tracks, year, month, name, created_at, visibility FROM monthly_playlists WHERE id = $1
`

func (q *Queries) GetPlaylist(ctx context.Context, id uuid.UUID) (MonthlyPlaylist, error) {
	row := q.db.QueryRow(ctx, getPlaylist, id)
	var i MonthlyPlaylist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Tracks,
		&i.Year,
		&i.Month,
		&i.Name,
		&i.CreatedAt,
		&i.Visibility,
	)
	return i, err
}

const getPrivateKey = `-- name: GetPrivateKey :one
SELECT value FROM private_keys WHERE kid = $1
`

func (q *Queries) GetPrivateKey(ctx context.Context, kid int32) (string, error) {
	row := q.db.QueryRow(ctx, getPrivateKey, kid)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getUserFromSession = `-- name: GetUserFromSession :one
SELECT id, spotify_user_id, email, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE refresh_token = $1
`

func (q *Queries) GetUserFromSession(ctx context.Context, refreshToken uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserFromSession, refreshToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SpotifyUserID,
		&i.Email,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserPlaylists = `-- name: GetUserPlaylists :many
SELECT id, user_id, tracks, year, month, name, created_at, visibility FROM monthly_playlists WHERE user_id = $1
`

func (q *Queries) GetUserPlaylists(ctx context.Context, userID uuid.UUID) ([]MonthlyPlaylist, error) {
	rows, err := q.db.Query(ctx, getUserPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonthlyPlaylist
	for rows.Next() {
		var i MonthlyPlaylist
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tracks,
			&i.Year,
			&i.Month,
			&i.Name,
			&i.CreatedAt,
			&i.Visibility,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriends = `-- name: ListFriends :many
SELECT u.id, u.spotify_user_id, u.email, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM friendships f
JOIN users u
  ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
  AND f.status = 'accepted'
`

func (q *Queries) ListFriends(ctx context.Context, userAID uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listFriends, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.SpotifyUserID,
			&i.Email,
			&i.SpotifyUserData,
			&i.CreatedAt,
			&i.RefreshToken,
			&i.RefreshExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomingRequests = `-- name: ListIncomingRequests :many
SELECT u.id, u.spotify_user_id, u.email, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.requester_id <> $1
AND f.status = 'pending'
`

func (q *Queries) ListIncomingRequests(ctx context.Context, userAID uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listIncomingRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.SpotifyUserID,
			&i.Email,
			&i.SpotifyUserData,
			&i.CreatedAt,
			&i.RefreshToken,
			&i.RefreshExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutgoingRequests = `-- name: ListOutgoingRequests :many
SELECT u.id, u.spotify_user_id, u.email, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.requester_id = $1
AND f.status = 'pending'
`

func (q *Queries) ListOutgoingRequests(ctx context.Context, userAID uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listOutgoingRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.SpotifyUserID,
			&i.Email,
			&i.SpotifyUserData,
			&i.CreatedAt,
			&i.RefreshToken,
			&i.RefreshExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectFriendRequest = `-- name: RejectFriendRequest :execrows
UPDATE friendships
    SET
        status = 'rejected',
        responded_at = NOW()
    WHERE
        user_a_id = LEAST($1, $2) AND
        user_b_id = GREATEST($1, $2)
`

type RejectFriendRequestParams struct {
	UserAID   uuid.UUID
	UserAID_2 uuid.UUID
}

func (q *Queries) RejectFriendRequest(ctx context.Context, arg RejectFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, rejectFriendRequest, arg.UserAID, arg.UserAID_2)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeFriendship = `-- name: RemoveFriendship :execrows
DELETE FROM friendships
    WHERE user_a_id = LEAST($1::uuid, $2::uuid) AND user_b_id = GREATEST($1::uuid, $2::uuid)
`

type RemoveFriendshipParams struct {
	UserAID uuid.UUID
	UserBID uuid.UUID
}

func (q *Queries) RemoveFriendship(ctx context.Context, arg RemoveFriendshipParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeFriendship, arg.UserAID, arg.UserBID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateVisibility = `-- name: UpdateVisibility :execrows
UPDATE monthly_playlists
    SET visibility = $1
    WHERE id = $2 AND user_id = $3
`

type UpdateVisibilityParams struct {
	Visibility PlaylistVisibility
	ID         uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) UpdateVisibility(ctx context.Context, arg UpdateVisibilityParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateVisibility, arg.Visibility, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertSpotifyCredentials = `-- name: UpsertSpotifyCredentials :exec
INSERT INTO spotify_tokens (
  user_id,
  access_token,
  token_type,
  scope,
  refresh_token
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
ON CONFLICT (user_id)
DO UPDATE SET
  access_token   = EXCLUDED.access_token,
  token_type     = EXCLUDED.token_type,
  scope          = EXCLUDED.scope,
  refresh_token  = EXCLUDED.refresh_token
`

type UpsertSpotifyCredentialsParams struct {
	UserID       string
	AccessToken  string
	TokenType    string
	Scope        string
	RefreshToken string
}

func (q *Queries) UpsertSpotifyCredentials(ctx context.Context, arg UpsertSpotifyCredentialsParams) error {
	_, err := q.db.Exec(ctx, upsertSpotifyCredentials,
		arg.UserID,
		arg.AccessToken,
		arg.TokenType,
		arg.Scope,
		arg.RefreshToken,
	)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (spotify_user_id, email, spotify_user_data)
VALUES ($1, $2, $3)
ON CONFLICT (spotify_user_id)
  DO UPDATE SET
    email  = EXCLUDED.email,
    spotify_user_data = EXCLUDED.spotify_user_data
RETURNING id, refresh_token
`

type UpsertUserParams struct {
	SpotifyUserID   string
	Email           string
	SpotifyUserData []byte
}

type UpsertUserRow struct {
	ID           uuid.UUID
	RefreshToken uuid.UUID
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (UpsertUserRow, error) {
	row := q.db.QueryRow(ctx, upsertUser, arg.SpotifyUserID, arg.Email, arg.SpotifyUserData)
	var i UpsertUserRow
	err := row.Scan(&i.ID, &i.RefreshToken)
	return i, err
}
