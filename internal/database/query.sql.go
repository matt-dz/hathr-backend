// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :one
UPDATE friendships
    SET
        status = 'accepted',
        responded_at = NOW()
    WHERE
        status = 'pending' AND
        user_a_id = LEAST($1::uuid, $2::uuid) AND
        user_b_id = GREATEST($1::uuid, $2::uuid) AND
        requester_id <> $1::uuid
RETURNING user_a_id, user_b_id, requester_id, status, requested_at, responded_at
`

type AcceptFriendRequestParams struct {
	ResponderID uuid.UUID `json:"responder_id"`
	RespondeeID uuid.UUID `json:"respondee_id"`
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, arg AcceptFriendRequestParams) (Friendship, error) {
	row := q.db.QueryRow(ctx, acceptFriendRequest, arg.ResponderID, arg.RespondeeID)
	var i Friendship
	err := row.Scan(
		&i.UserAID,
		&i.UserBID,
		&i.RequesterID,
		&i.Status,
		&i.RequestedAt,
		&i.RespondedAt,
	)
	return i, err
}

const createFriendRequest = `-- name: CreateFriendRequest :one
INSERT INTO friendships (
  user_a_id,
  user_b_id,
  requester_id,
  status,
  requested_at,
  responded_at
)
VALUES (
  LEAST($1::uuid, $2::uuid),
  GREATEST($1::uuid, $2::uuid),
  $1::uuid,
  'pending',
  now(),
  NULL
)
RETURNING user_a_id, user_b_id, requester_id, status, requested_at, responded_at
`

type CreateFriendRequestParams struct {
	Requester uuid.UUID `json:"requester"`
	Requestee uuid.UUID `json:"requestee"`
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) (Friendship, error) {
	row := q.db.QueryRow(ctx, createFriendRequest, arg.Requester, arg.Requestee)
	var i Friendship
	err := row.Scan(
		&i.UserAID,
		&i.UserBID,
		&i.RequesterID,
		&i.Status,
		&i.RequestedAt,
		&i.RespondedAt,
	)
	return i, err
}

const createMonthlyPlaylist = `-- name: CreateMonthlyPlaylist :one
INSERT INTO playlists(user_id, tracks, year, month, name, type)
VALUES ($1, $2, $3, $4, $5, 'monthly')
RETURNING id
`

type CreateMonthlyPlaylistParams struct {
	UserID uuid.UUID   `json:"user_id"`
	Tracks [][]byte    `json:"tracks"`
	Year   int32       `json:"year"`
	Month  pgtype.Int4 `json:"month"`
	Name   string      `json:"name"`
}

func (q *Queries) CreateMonthlyPlaylist(ctx context.Context, arg CreateMonthlyPlaylistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createMonthlyPlaylist,
		arg.UserID,
		arg.Tracks,
		arg.Year,
		arg.Month,
		arg.Name,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createSpotifyUser = `-- name: CreateSpotifyUser :one
INSERT INTO users (spotify_user_id, email, spotify_user_data)
VALUES ($1, $2, $3)
ON CONFLICT (spotify_user_id) DO UPDATE
SET email = users.email -- no op
RETURNING id, display_name, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at
`

type CreateSpotifyUserParams struct {
	SpotifyUserID   string `json:"spotify_user_id"`
	Email           string `json:"email"`
	SpotifyUserData []byte `json:"spotify_user_data"`
}

func (q *Queries) CreateSpotifyUser(ctx context.Context, arg CreateSpotifyUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createSpotifyUser, arg.SpotifyUserID, arg.Email, arg.SpotifyUserData)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const deleteFriendRequest = `-- name: DeleteFriendRequest :execrows
DELETE FROM friendships
    WHERE user_a_id = LEAST($1::uuid, $2::uuid) AND user_b_id = GREATEST($1::uuid, $2::uuid)
    AND status = 'pending'
`

type DeleteFriendRequestParams struct {
	RequesterID uuid.UUID `json:"requester_id"`
	RequesteeID uuid.UUID `json:"requestee_id"`
}

func (q *Queries) DeleteFriendRequest(ctx context.Context, arg DeleteFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteFriendRequest, arg.RequesterID, arg.RequesteeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getFriendPlaylists = `-- name: GetFriendPlaylists :many
WITH friends AS (
    SELECT
        CASE
            WHEN f.user_a_id = $1 THEN f.user_b_id
            ELSE f.user_a_id
        END AS friend_id
    FROM friendships f
    WHERE f.status    = 'accepted'
    AND (f.user_a_id = $1 OR f.user_b_id = $1)
)
SELECT
    u.id, u.display_name, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at,
    p.id AS playlist_id,
    p.type AS playlist_type,
    p.name AS playlist_name,
    p.year AS playlist_year,
    p.week AS playlist_week,
    p.month AS playlist_month,
    p.created_at AS playlist_created_at,
    p.visibility AS playlist_visibility
FROM friends fr
JOIN users u
    ON u.id = fr.friend_id
LEFT JOIN LATERAL (
    SELECT id, type, name, year, week, month, visibility, created_at
    FROM playlists
    WHERE user_id = fr.friend_id AND visibility = 'public'
    ORDER BY created_at DESC
    LIMIT 1
) p ON true
ORDER BY u.username
`

type GetFriendPlaylistsRow struct {
	User               User               `json:"user"`
	PlaylistID         uuid.UUID          `json:"playlist_id"`
	PlaylistType       PlaylistType       `json:"playlist_type"`
	PlaylistName       string             `json:"playlist_name"`
	PlaylistYear       int32              `json:"playlist_year"`
	PlaylistWeek       pgtype.Int4        `json:"playlist_week"`
	PlaylistMonth      pgtype.Int4        `json:"playlist_month"`
	PlaylistCreatedAt  pgtype.Timestamptz `json:"playlist_created_at"`
	PlaylistVisibility PlaylistVisibility `json:"playlist_visibility"`
}

func (q *Queries) GetFriendPlaylists(ctx context.Context, userAID uuid.UUID) ([]GetFriendPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getFriendPlaylists, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendPlaylistsRow
	for rows.Next() {
		var i GetFriendPlaylistsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.PlaylistID,
			&i.PlaylistType,
			&i.PlaylistName,
			&i.PlaylistYear,
			&i.PlaylistWeek,
			&i.PlaylistMonth,
			&i.PlaylistCreatedAt,
			&i.PlaylistVisibility,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPrivateKey = `-- name: GetLatestPrivateKey :one
SELECT kid, value FROM private_keys
ORDER BY kid DESC
LIMIT 1
`

func (q *Queries) GetLatestPrivateKey(ctx context.Context) (PrivateKey, error) {
	row := q.db.QueryRow(ctx, getLatestPrivateKey)
	var i PrivateKey
	err := row.Scan(&i.Kid, &i.Value)
	return i, err
}

const getPersonalPlaylists = `-- name: GetPersonalPlaylists :many
SELECT id, user_id, tracks, type, name, created_at, visibility, year, week, month FROM playlists WHERE user_id = $1
`

func (q *Queries) GetPersonalPlaylists(ctx context.Context, userID uuid.UUID) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, getPersonalPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tracks,
			&i.Type,
			&i.Name,
			&i.CreatedAt,
			&i.Visibility,
			&i.Year,
			&i.Week,
			&i.Month,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonalProfile = `-- name: GetPersonalProfile :one
SELECT id, display_name, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE id = $1
`

func (q *Queries) GetPersonalProfile(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getPersonalProfile, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getPlaylist = `-- name: GetPlaylist :one
SELECT p.id, p.user_id, p.tracks, p.type, p.name, p.created_at, p.visibility, p.year, p.week, p.month, u.id, u.display_name, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM playlists p
JOIN users u
  ON u.id = p.user_id
WHERE p.id= $1
`

type GetPlaylistRow struct {
	Playlist Playlist `json:"playlist"`
	User     User     `json:"user"`
}

func (q *Queries) GetPlaylist(ctx context.Context, id uuid.UUID) (GetPlaylistRow, error) {
	row := q.db.QueryRow(ctx, getPlaylist, id)
	var i GetPlaylistRow
	err := row.Scan(
		&i.Playlist.ID,
		&i.Playlist.UserID,
		&i.Playlist.Tracks,
		&i.Playlist.Type,
		&i.Playlist.Name,
		&i.Playlist.CreatedAt,
		&i.Playlist.Visibility,
		&i.Playlist.Year,
		&i.Playlist.Week,
		&i.Playlist.Month,
		&i.User.ID,
		&i.User.DisplayName,
		&i.User.Username,
		&i.User.Email,
		&i.User.RegisteredAt,
		&i.User.Role,
		&i.User.SpotifyUserID,
		&i.User.SpotifyUserData,
		&i.User.CreatedAt,
		&i.User.RefreshToken,
		&i.User.RefreshExpiresAt,
	)
	return i, err
}

const getPrivateKey = `-- name: GetPrivateKey :one
SELECT value FROM private_keys WHERE kid = $1
`

func (q *Queries) GetPrivateKey(ctx context.Context, kid int32) (string, error) {
	row := q.db.QueryRow(ctx, getPrivateKey, kid)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getUserById = `-- name: GetUserById :one
SELECT u.id, u.display_name, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM users u
LEFT JOIN friendships f
    ON (
    f.user_a_id = LEAST($1::uuid, u.id) AND f.user_b_id = GREATEST($1::uuid, u.id)
    )
WHERE u.id = $2::uuid AND
      (f.status IS NULL OR f.status <> 'blocked')
`

type GetUserByIdParams struct {
	Searcher uuid.UUID `json:"searcher"`
	Searchee uuid.UUID `json:"searchee"`
}

func (q *Queries) GetUserById(ctx context.Context, arg GetUserByIdParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, arg.Searcher, arg.Searchee)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserBySpotifyId = `-- name: GetUserBySpotifyId :one
SELECT id, display_name, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE spotify_user_id = $1
`

func (q *Queries) GetUserBySpotifyId(ctx context.Context, spotifyUserID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserBySpotifyId, spotifyUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserFromSession = `-- name: GetUserFromSession :one
SELECT id, display_name, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE refresh_token = $1
`

func (q *Queries) GetUserFromSession(ctx context.Context, refreshToken uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserFromSession, refreshToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserPlaylists = `-- name: GetUserPlaylists :many
SELECT p.id, p.user_id, p.tracks, p.type, p.name, p.created_at, p.visibility, p.year, p.week, p.month
FROM playlists p
LEFT JOIN friendships f
  ON (f.user_a_id = LEAST($1::uuid, p.user_id) AND f.user_b_id = GREATEST($1::uuid, p.user_id))
WHERE
    p.user_id = $2::uuid AND
    (f.status IS NULL OR f.status <> 'blocked') AND
    (p.visibility = 'public' OR
    (p.visibility = 'private' AND p.user_id = $1::uuid))
`

type GetUserPlaylistsParams struct {
	SearcherID uuid.UUID `json:"searcher_id"`
	UserID     uuid.UUID `json:"user_id"`
}

func (q *Queries) GetUserPlaylists(ctx context.Context, arg GetUserPlaylistsParams) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, getUserPlaylists, arg.SearcherID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tracks,
			&i.Type,
			&i.Name,
			&i.CreatedAt,
			&i.Visibility,
			&i.Year,
			&i.Week,
			&i.Month,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriends = `-- name: ListFriends :many
SELECT u.id, u.display_name, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM friendships f
JOIN users u
  ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
  AND f.status = 'accepted'
`

func (q *Queries) ListFriends(ctx context.Context, userAID uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listFriends, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Username,
			&i.Email,
			&i.RegisteredAt,
			&i.Role,
			&i.SpotifyUserID,
			&i.SpotifyUserData,
			&i.CreatedAt,
			&i.RefreshToken,
			&i.RefreshExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomingRequests = `-- name: ListIncomingRequests :many
SELECT u.id, u.display_name, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at, f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.requester_id <> $1
AND f.status = 'pending'
`

type ListIncomingRequestsRow struct {
	User       User       `json:"user"`
	Friendship Friendship `json:"friendship"`
}

func (q *Queries) ListIncomingRequests(ctx context.Context, userAID uuid.UUID) ([]ListIncomingRequestsRow, error) {
	rows, err := q.db.Query(ctx, listIncomingRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIncomingRequestsRow
	for rows.Next() {
		var i ListIncomingRequestsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.Friendship.UserAID,
			&i.Friendship.UserBID,
			&i.Friendship.RequesterID,
			&i.Friendship.Status,
			&i.Friendship.RequestedAt,
			&i.Friendship.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutgoingRequests = `-- name: ListOutgoingRequests :many
SELECT u.id, u.display_name, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at, f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.requester_id = $1
AND f.status = 'pending'
`

type ListOutgoingRequestsRow struct {
	User       User       `json:"user"`
	Friendship Friendship `json:"friendship"`
}

func (q *Queries) ListOutgoingRequests(ctx context.Context, userAID uuid.UUID) ([]ListOutgoingRequestsRow, error) {
	rows, err := q.db.Query(ctx, listOutgoingRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOutgoingRequestsRow
	for rows.Next() {
		var i ListOutgoingRequestsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.Friendship.UserAID,
			&i.Friendship.UserBID,
			&i.Friendship.RequesterID,
			&i.Friendship.Status,
			&i.Friendship.RequestedAt,
			&i.Friendship.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequests = `-- name: ListRequests :many
SELECT
    u.id, u.display_name, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at,
    f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.status = 'pending'
`

type ListRequestsRow struct {
	User       User       `json:"user"`
	Friendship Friendship `json:"friendship"`
}

func (q *Queries) ListRequests(ctx context.Context, userAID uuid.UUID) ([]ListRequestsRow, error) {
	rows, err := q.db.Query(ctx, listRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRequestsRow
	for rows.Next() {
		var i ListRequestsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.Friendship.UserAID,
			&i.Friendship.UserBID,
			&i.Friendship.RequesterID,
			&i.Friendship.Status,
			&i.Friendship.RequestedAt,
			&i.Friendship.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFriendship = `-- name: RemoveFriendship :execrows
DELETE FROM friendships
    WHERE user_a_id = LEAST($1::uuid, $2::uuid) AND user_b_id = GREATEST($1::uuid, $2::uuid)
`

type RemoveFriendshipParams struct {
	UserAID uuid.UUID `json:"user_a_id"`
	UserBID uuid.UUID `json:"user_b_id"`
}

func (q *Queries) RemoveFriendship(ctx context.Context, arg RemoveFriendshipParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeFriendship, arg.UserAID, arg.UserBID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT
    u.id, u.display_name, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at,
    f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM users u
LEFT JOIN friendships f
  ON f.user_a_id = LEAST($1::uuid,  u.id)
 AND f.user_b_id = GREATEST($1::uuid, u.id)
WHERE
  similarity(u.username, $2::text) > 0.2
  AND $1::uuid <> u.id
  AND (f.status IS NULL OR f.status <> 'blocked')
ORDER BY similarity(u.username, $2::text) DESC
LIMIT 10
`

type SearchUsersParams struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
}

type SearchUsersRow struct {
	User        User                 `json:"user"`
	UserAID     uuid.UUID            `json:"user_a_id"`
	UserBID     uuid.UUID            `json:"user_b_id"`
	RequesterID uuid.UUID            `json:"requester_id"`
	Status      NullFriendshipStatus `json:"status"`
	RequestedAt pgtype.Timestamp     `json:"requested_at"`
	RespondedAt pgtype.Timestamp     `json:"responded_at"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := q.db.Query(ctx, searchUsers, arg.ID, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersRow
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.UserAID,
			&i.UserBID,
			&i.RequesterID,
			&i.Status,
			&i.RequestedAt,
			&i.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signUpUser = `-- name: SignUpUser :one
UPDATE users
SET username = $1, display_name = $2, registered_at = now()
WHERE id = $3
RETURNING id, display_name, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at
`

type SignUpUserParams struct {
	Username    pgtype.Text `json:"username"`
	DisplayName pgtype.Text `json:"display_name"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) SignUpUser(ctx context.Context, arg SignUpUserParams) (User, error) {
	row := q.db.QueryRow(ctx, signUpUser, arg.Username, arg.DisplayName, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const updateVisibility = `-- name: UpdateVisibility :execrows
UPDATE playlists
    SET visibility = $1
    WHERE id = $2 AND user_id = $3
`

type UpdateVisibilityParams struct {
	Visibility PlaylistVisibility `json:"visibility"`
	ID         uuid.UUID          `json:"id"`
	UserID     uuid.UUID          `json:"user_id"`
}

func (q *Queries) UpdateVisibility(ctx context.Context, arg UpdateVisibilityParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateVisibility, arg.Visibility, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertSpotifyCredentials = `-- name: UpsertSpotifyCredentials :exec
INSERT INTO spotify_tokens (
  user_id,
  access_token,
  token_type,
  scope,
  refresh_token
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
ON CONFLICT (user_id)
DO UPDATE SET
  access_token   = EXCLUDED.access_token,
  token_type     = EXCLUDED.token_type,
  scope          = EXCLUDED.scope,
  refresh_token  = EXCLUDED.refresh_token
`

type UpsertSpotifyCredentialsParams struct {
	UserID       string `json:"user_id"`
	AccessToken  string `json:"access_token"`
	TokenType    string `json:"token_type"`
	Scope        string `json:"scope"`
	RefreshToken string `json:"refresh_token"`
}

func (q *Queries) UpsertSpotifyCredentials(ctx context.Context, arg UpsertSpotifyCredentialsParams) error {
	_, err := q.db.Exec(ctx, upsertSpotifyCredentials,
		arg.UserID,
		arg.AccessToken,
		arg.TokenType,
		arg.Scope,
		arg.RefreshToken,
	)
	return err
}
