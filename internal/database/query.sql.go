// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"hathr-backend/internal/spotify/models"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :one
UPDATE friendships
    SET
        status = 'accepted',
        responded_at = NOW()
    WHERE
        status = 'pending' AND
        user_a_id = LEAST($1::uuid, $2::uuid) AND
        user_b_id = GREATEST($1::uuid, $2::uuid) AND
        requester_id <> $1::uuid
RETURNING user_a_id, user_b_id, requester_id, status, requested_at, responded_at
`

type AcceptFriendRequestParams struct {
	ResponderID uuid.UUID `json:"responder_id"`
	RespondeeID uuid.UUID `json:"respondee_id"`
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, arg AcceptFriendRequestParams) (Friendship, error) {
	row := q.db.QueryRow(ctx, acceptFriendRequest, arg.ResponderID, arg.RespondeeID)
	var i Friendship
	err := row.Scan(
		&i.UserAID,
		&i.UserBID,
		&i.RequesterID,
		&i.Status,
		&i.RequestedAt,
		&i.RespondedAt,
	)
	return i, err
}

const addSpotifyPlaylistTracks = `-- name: AddSpotifyPlaylistTracks :exec
INSERT INTO spotify_playlist_tracks (playlist_id, track_id)
SELECT $1::UUID, t
FROM unnest($2::TEXT[]) AS t
ON CONFLICT DO NOTHING
`

type AddSpotifyPlaylistTracksParams struct {
	PlaylistID uuid.UUID `json:"playlist_id"`
	TrackIds   []string  `json:"track_ids"`
}

func (q *Queries) AddSpotifyPlaylistTracks(ctx context.Context, arg AddSpotifyPlaylistTracksParams) error {
	_, err := q.db.Exec(ctx, addSpotifyPlaylistTracks, arg.PlaylistID, arg.TrackIds)
	return err
}

const createAdminUser = `-- name: CreateAdminUser :exec
INSERT INTO users (username, password, email, role, registered_at)
VALUES ($1, $2, $3, 'admin', now())
`

type CreateAdminUserParams struct {
	Username pgtype.Text `json:"username"`
	Password pgtype.Text `json:"password"`
	Email    string      `json:"email"`
}

func (q *Queries) CreateAdminUser(ctx context.Context, arg CreateAdminUserParams) error {
	_, err := q.db.Exec(ctx, createAdminUser, arg.Username, arg.Password, arg.Email)
	return err
}

const createFriendRequest = `-- name: CreateFriendRequest :one
INSERT INTO friendships (
  user_a_id,
  user_b_id,
  requester_id,
  status,
  requested_at,
  responded_at
)
VALUES (
  LEAST($1::uuid, $2::uuid),
  GREATEST($1::uuid, $2::uuid),
  $1::uuid,
  'pending',
  now(),
  NULL
)
RETURNING user_a_id, user_b_id, requester_id, status, requested_at, responded_at
`

type CreateFriendRequestParams struct {
	Requester uuid.UUID `json:"requester"`
	Requestee uuid.UUID `json:"requestee"`
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) (Friendship, error) {
	row := q.db.QueryRow(ctx, createFriendRequest, arg.Requester, arg.Requestee)
	var i Friendship
	err := row.Scan(
		&i.UserAID,
		&i.UserBID,
		&i.RequesterID,
		&i.Status,
		&i.RequestedAt,
		&i.RespondedAt,
	)
	return i, err
}

const createMonthlySpotifyPlaylist = `-- name: CreateMonthlySpotifyPlaylist :one
INSERT INTO playlists (user_id, name, type, visibility, year, month)
VALUES ($1, $2, 'monthly', 'public', $3, $4)
ON CONFLICT (user_id, type, year, month) DO UPDATE
    SET month = playlists.month -- no-op
RETURNING id as playlist_id
`

type CreateMonthlySpotifyPlaylistParams struct {
	UserID uuid.UUID   `json:"user_id"`
	Name   string      `json:"name"`
	Year   int32       `json:"year"`
	Month  pgtype.Int4 `json:"month"`
}

func (q *Queries) CreateMonthlySpotifyPlaylist(ctx context.Context, arg CreateMonthlySpotifyPlaylistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createMonthlySpotifyPlaylist,
		arg.UserID,
		arg.Name,
		arg.Year,
		arg.Month,
	)
	var playlist_id uuid.UUID
	err := row.Scan(&playlist_id)
	return playlist_id, err
}

const createSpotifyPlay = `-- name: CreateSpotifyPlay :exec
INSERT INTO spotify_plays (user_id, track_id, played_at)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type CreateSpotifyPlayParams struct {
	UserID   uuid.UUID          `json:"user_id"`
	TrackID  string             `json:"track_id"`
	PlayedAt pgtype.Timestamptz `json:"played_at"`
}

func (q *Queries) CreateSpotifyPlay(ctx context.Context, arg CreateSpotifyPlayParams) error {
	_, err := q.db.Exec(ctx, createSpotifyPlay, arg.UserID, arg.TrackID, arg.PlayedAt)
	return err
}

const createSpotifyPlays = `-- name: CreateSpotifyPlays :exec
INSERT INTO spotify_plays (user_id, track_id, played_at)
SELECT $1::UUID, ids, played
FROM
    unnest($2::TEXT[]) AS ids,
    unnest($3::TIMESTAMPTZ[]) AS played
ON CONFLICT DO NOTHING
`

type CreateSpotifyPlaysParams struct {
	UserID uuid.UUID            `json:"user_id"`
	Ids    []string             `json:"ids"`
	Played []pgtype.Timestamptz `json:"played"`
}

func (q *Queries) CreateSpotifyPlays(ctx context.Context, arg CreateSpotifyPlaysParams) error {
	_, err := q.db.Exec(ctx, createSpotifyPlays, arg.UserID, arg.Ids, arg.Played)
	return err
}

const createSpotifyTracks = `-- name: CreateSpotifyTracks :exec
INSERT INTO spotify_tracks (
  id, name, artists, popularity,
  image_url, href, raw, updated_at
)
SELECT
  t.id,
  t.name,
  t.artists,
  t.popularity,
  t.image_url,
  t.href,
  t.raw,
  now()
FROM unnest($1::spotify_track_input[]) AS t(
  id, name, artists, popularity, image_url, href, raw
)
ON CONFLICT DO NOTHING
`

func (q *Queries) CreateSpotifyTracks(ctx context.Context, tracks []models.SpotifyTrackInput) error {
	_, err := q.db.Exec(ctx, createSpotifyTracks, tracks)
	return err
}

const createSpotifyUser = `-- name: CreateSpotifyUser :one
INSERT INTO users (spotify_user_id, email, spotify_user_data)
VALUES ($1, $2, $3)
ON CONFLICT (spotify_user_id) DO UPDATE
SET email = users.email -- no op
RETURNING id, display_name, username, image_url, email, registered_at, role, password, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at
`

type CreateSpotifyUserParams struct {
	SpotifyUserID   pgtype.Text `json:"spotify_user_id"`
	Email           string      `json:"email"`
	SpotifyUserData []byte      `json:"spotify_user_data"`
}

func (q *Queries) CreateSpotifyUser(ctx context.Context, arg CreateSpotifyUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createSpotifyUser, arg.SpotifyUserID, arg.Email, arg.SpotifyUserData)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.ImageUrl,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.Password,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const createWeeklySpotifyPlaylist = `-- name: CreateWeeklySpotifyPlaylist :one
INSERT INTO playlists (user_id, name, type, visibility, year, week)
VALUES ($1, $2, 'weekly', 'public', $3, $4)
ON CONFLICT (user_id, type, year, week) DO UPDATE
    SET week = playlists.week -- no-op
RETURNING id as playlist_id
`

type CreateWeeklySpotifyPlaylistParams struct {
	UserID uuid.UUID          `json:"user_id"`
	Name   string             `json:"name"`
	Year   int32              `json:"year"`
	Week   pgtype.Timestamptz `json:"week"`
}

func (q *Queries) CreateWeeklySpotifyPlaylist(ctx context.Context, arg CreateWeeklySpotifyPlaylistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createWeeklySpotifyPlaylist,
		arg.UserID,
		arg.Name,
		arg.Year,
		arg.Week,
	)
	var playlist_id uuid.UUID
	err := row.Scan(&playlist_id)
	return playlist_id, err
}

const deleteFriendRequest = `-- name: DeleteFriendRequest :execrows
DELETE FROM friendships
    WHERE user_a_id = LEAST($1::uuid, $2::uuid) AND user_b_id = GREATEST($1::uuid, $2::uuid)
    AND status = 'pending'
`

type DeleteFriendRequestParams struct {
	RequesterID uuid.UUID `json:"requester_id"`
	RequesteeID uuid.UUID `json:"requestee_id"`
}

func (q *Queries) DeleteFriendRequest(ctx context.Context, arg DeleteFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteFriendRequest, arg.RequesterID, arg.RequesteeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAdminUser = `-- name: GetAdminUser :one
SELECT id, role, registered_at, refresh_token, password
FROM users
WHERE
    username = $1
    AND role = 'admin'
    AND registered_at IS NOT NULL
`

type GetAdminUserRow struct {
	ID           uuid.UUID          `json:"id"`
	Role         Role               `json:"role"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	RefreshToken uuid.UUID          `json:"refresh_token"`
	Password     pgtype.Text        `json:"password"`
}

func (q *Queries) GetAdminUser(ctx context.Context, username pgtype.Text) (GetAdminUserRow, error) {
	row := q.db.QueryRow(ctx, getAdminUser, username)
	var i GetAdminUserRow
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.RegisteredAt,
		&i.RefreshToken,
		&i.Password,
	)
	return i, err
}

const getFriendPlaylists = `-- name: GetFriendPlaylists :many
WITH friends AS (
    SELECT
        CASE
            WHEN f.user_a_id = $1 THEN f.user_b_id
            ELSE f.user_a_id
        END AS friend_id
    FROM friendships f
    WHERE f.status    = 'accepted'
    AND (f.user_a_id = $1 OR f.user_b_id = $1)
)
SELECT
    u.id, u.display_name, u.username, u.image_url, u.email, u.registered_at, u.role, u.password, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at,
    p.id AS playlist_id,
    p.type AS playlist_type,
    p.name AS playlist_name,
    p.year AS playlist_year,
    p.week AS playlist_week,
    p.month AS playlist_month,
    p.created_at AS playlist_created_at,
    p.visibility AS playlist_visibility,
    p.num_tracks
FROM friends fr
JOIN users u
    ON u.id = fr.friend_id
LEFT JOIN LATERAL (
    SELECT
        id, type, name, year, week,
        month, created_at, visibility,
        COUNT(*) as num_tracks
    FROM playlists
    JOIN spotify_playlist_tracks ppt ON ppt.playlist_id = playlists.id
    WHERE user_id = fr.friend_id AND visibility = 'public'
    GROUP BY
        id, type, name, year, week,
        month, created_at, visibility
    ORDER BY created_at DESC
    LIMIT 1
) p ON true
ORDER BY u.username
`

type GetFriendPlaylistsRow struct {
	User               User               `json:"user"`
	PlaylistID         uuid.UUID          `json:"playlist_id"`
	PlaylistType       PlaylistType       `json:"playlist_type"`
	PlaylistName       string             `json:"playlist_name"`
	PlaylistYear       int32              `json:"playlist_year"`
	PlaylistWeek       pgtype.Timestamptz `json:"playlist_week"`
	PlaylistMonth      pgtype.Int4        `json:"playlist_month"`
	PlaylistCreatedAt  pgtype.Timestamptz `json:"playlist_created_at"`
	PlaylistVisibility PlaylistVisibility `json:"playlist_visibility"`
	NumTracks          int64              `json:"num_tracks"`
}

func (q *Queries) GetFriendPlaylists(ctx context.Context, userAID uuid.UUID) ([]GetFriendPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getFriendPlaylists, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendPlaylistsRow
	for rows.Next() {
		var i GetFriendPlaylistsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.ImageUrl,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.Password,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.PlaylistID,
			&i.PlaylistType,
			&i.PlaylistName,
			&i.PlaylistYear,
			&i.PlaylistWeek,
			&i.PlaylistMonth,
			&i.PlaylistCreatedAt,
			&i.PlaylistVisibility,
			&i.NumTracks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPrivateKey = `-- name: GetLatestPrivateKey :one
SELECT kid, value FROM private_keys
ORDER BY kid DESC
LIMIT 1
`

func (q *Queries) GetLatestPrivateKey(ctx context.Context) (PrivateKey, error) {
	row := q.db.QueryRow(ctx, getLatestPrivateKey)
	var i PrivateKey
	err := row.Scan(&i.Kid, &i.Value)
	return i, err
}

const getPersonalPlaylists = `-- name: GetPersonalPlaylists :many
SELECT
    p.id, p.type, p.name, p.user_id,
    p.created_at, p.visibility, p.year,
    p.week, p.month, COUNT(st) AS num_tracks
FROM playlists p
JOIN spotify_playlist_tracks ppt
    ON ppt.playlist_id = p.id
JOIN spotify_tracks st
    ON st.id = ppt.track_id
WHERE p.user_id = $1
GROUP BY
    p.id, p.type, p.name, p.user_id,
    p.created_at, p.visibility, p.year,
    p.week, p.month
`

type GetPersonalPlaylistsRow struct {
	ID         uuid.UUID          `json:"id"`
	Type       PlaylistType       `json:"type"`
	Name       string             `json:"name"`
	UserID     uuid.UUID          `json:"user_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Visibility PlaylistVisibility `json:"visibility"`
	Year       int32              `json:"year"`
	Week       pgtype.Timestamptz `json:"week"`
	Month      pgtype.Int4        `json:"month"`
	NumTracks  int64              `json:"num_tracks"`
}

func (q *Queries) GetPersonalPlaylists(ctx context.Context, userID uuid.UUID) ([]GetPersonalPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getPersonalPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPersonalPlaylistsRow
	for rows.Next() {
		var i GetPersonalPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Name,
			&i.UserID,
			&i.CreatedAt,
			&i.Visibility,
			&i.Year,
			&i.Week,
			&i.Month,
			&i.NumTracks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonalProfile = `-- name: GetPersonalProfile :one
SELECT id, display_name, username, image_url, email, registered_at, role, password, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE id = $1
`

func (q *Queries) GetPersonalProfile(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getPersonalProfile, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.ImageUrl,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.Password,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getPrivateKey = `-- name: GetPrivateKey :one
SELECT value FROM private_keys WHERE kid = $1
`

func (q *Queries) GetPrivateKey(ctx context.Context, kid int32) (string, error) {
	row := q.db.QueryRow(ctx, getPrivateKey, kid)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getSpotifyPlaylistTracks = `-- name: GetSpotifyPlaylistTracks :many
SELECT
  st.id,
  st.name,
  st.artists,
  st.image_url,
  st.href
FROM spotify_playlist_tracks ppt
JOIN spotify_tracks st ON st.id = ppt.track_id
WHERE ppt.playlist_id = $1
`

type GetSpotifyPlaylistTracksRow struct {
	ID       string      `json:"id"`
	Name     string      `json:"name"`
	Artists  []string    `json:"artists"`
	ImageUrl pgtype.Text `json:"image_url"`
	Href     string      `json:"href"`
}

func (q *Queries) GetSpotifyPlaylistTracks(ctx context.Context, playlistID uuid.UUID) ([]GetSpotifyPlaylistTracksRow, error) {
	rows, err := q.db.Query(ctx, getSpotifyPlaylistTracks, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpotifyPlaylistTracksRow
	for rows.Next() {
		var i GetSpotifyPlaylistTracksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Artists,
			&i.ImageUrl,
			&i.Href,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpotifyPlaylistWithOwner = `-- name: GetSpotifyPlaylistWithOwner :one
SELECT
    p.id, p.user_id, p.type, p.name, p.created_at, p.visibility, p.year, p.week, p.month,
    u.id, u.display_name, u.username, u.image_url, u.email, u.registered_at, u.role, u.password, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM playlists p
JOIN users u
  ON u.id = p.user_id
WHERE p.id = $1
`

type GetSpotifyPlaylistWithOwnerRow struct {
	Playlist Playlist `json:"playlist"`
	User     User     `json:"user"`
}

func (q *Queries) GetSpotifyPlaylistWithOwner(ctx context.Context, id uuid.UUID) (GetSpotifyPlaylistWithOwnerRow, error) {
	row := q.db.QueryRow(ctx, getSpotifyPlaylistWithOwner, id)
	var i GetSpotifyPlaylistWithOwnerRow
	err := row.Scan(
		&i.Playlist.ID,
		&i.Playlist.UserID,
		&i.Playlist.Type,
		&i.Playlist.Name,
		&i.Playlist.CreatedAt,
		&i.Playlist.Visibility,
		&i.Playlist.Year,
		&i.Playlist.Week,
		&i.Playlist.Month,
		&i.User.ID,
		&i.User.DisplayName,
		&i.User.Username,
		&i.User.ImageUrl,
		&i.User.Email,
		&i.User.RegisteredAt,
		&i.User.Role,
		&i.User.Password,
		&i.User.SpotifyUserID,
		&i.User.SpotifyUserData,
		&i.User.CreatedAt,
		&i.User.RefreshToken,
		&i.User.RefreshExpiresAt,
	)
	return i, err
}

const getSpotifyTokens = `-- name: GetSpotifyTokens :one
SELECT
    t.access_token,
    t.refresh_token,
    t.token_expires
FROM spotify_tokens t
JOIN users u
    ON u.spotify_user_id = t.user_id
WHERE u.id = $1
FOR UPDATE OF t
`

type GetSpotifyTokensRow struct {
	AccessToken  string             `json:"access_token"`
	RefreshToken string             `json:"refresh_token"`
	TokenExpires pgtype.Timestamptz `json:"token_expires"`
}

func (q *Queries) GetSpotifyTokens(ctx context.Context, id uuid.UUID) (GetSpotifyTokensRow, error) {
	row := q.db.QueryRow(ctx, getSpotifyTokens, id)
	var i GetSpotifyTokensRow
	err := row.Scan(&i.AccessToken, &i.RefreshToken, &i.TokenExpires)
	return i, err
}

const getTopSpotifyTracks = `-- name: GetTopSpotifyTracks :many
SELECT
    p.track_id,
    COUNT (*) AS plays
FROM spotify_plays p
JOIN spotify_tracks t ON p.track_id = t.id
WHERE
    p.user_id = $2::UUID
    AND p.played_at >= $3::TIMESTAMPTZ
    AND p.played_at < $4::TIMESTAMPTZ
GROUP BY
    p.track_id, t.name, t.artists, t.image_url
ORDER BY plays DESC
LIMIT $1
`

type GetTopSpotifyTracksParams struct {
	Limit     int32              `json:"limit"`
	UserID    uuid.UUID          `json:"user_id"`
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
}

type GetTopSpotifyTracksRow struct {
	TrackID string `json:"track_id"`
	Plays   int64  `json:"plays"`
}

func (q *Queries) GetTopSpotifyTracks(ctx context.Context, arg GetTopSpotifyTracksParams) ([]GetTopSpotifyTracksRow, error) {
	rows, err := q.db.Query(ctx, getTopSpotifyTracks,
		arg.Limit,
		arg.UserID,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSpotifyTracksRow
	for rows.Next() {
		var i GetTopSpotifyTracksRow
		if err := rows.Scan(&i.TrackID, &i.Plays); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBySpotifyId = `-- name: GetUserBySpotifyId :one
SELECT id, display_name, username, image_url, email, registered_at, role, password, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE spotify_user_id = $1
`

func (q *Queries) GetUserBySpotifyId(ctx context.Context, spotifyUserID pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserBySpotifyId, spotifyUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.ImageUrl,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.Password,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT u.id, u.display_name, u.username, u.image_url, u.email, u.registered_at, u.role, u.password, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM users u
LEFT JOIN friendships f
    ON (
    f.user_a_id = LEAST($1::uuid, u.id) AND f.user_b_id = GREATEST($1::uuid, u.id)
    )
WHERE u.username = $2::text AND
      (f.status IS NULL OR f.status <> 'blocked')
`

type GetUserByUsernameParams struct {
	Searcher uuid.UUID `json:"searcher"`
	Username string    `json:"username"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, arg GetUserByUsernameParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, arg.Searcher, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.ImageUrl,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.Password,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserFromSession = `-- name: GetUserFromSession :one
SELECT id, display_name, username, image_url, email, registered_at, role, password, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE refresh_token = $1
`

func (q *Queries) GetUserFromSession(ctx context.Context, refreshToken uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserFromSession, refreshToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.ImageUrl,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.Password,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserPlaylists = `-- name: GetUserPlaylists :many
SELECT
    p.id, p.user_id, ARRAY_LENGTH(p.tracks, 1) AS num_tracks,
    p.type, p.name, p.created_at, p.visibility,
    p.year, p.week, p.month
FROM playlists p
JOIN users u
    ON u.id = p.user_id
LEFT JOIN friendships f
    ON (f.user_a_id = LEAST($1::uuid, p.user_id) AND f.user_b_id = GREATEST($1::uuid, p.user_id))
WHERE
    u.username = $2 AND
    (f.status IS NULL OR f.status <> 'blocked') AND
    (p.visibility = 'public' OR
    (p.visibility = 'private' AND p.user_id = $1::uuid))
`

type GetUserPlaylistsParams struct {
	UserID   uuid.UUID   `json:"user_id"`
	Username pgtype.Text `json:"username"`
}

type GetUserPlaylistsRow struct {
	ID         uuid.UUID          `json:"id"`
	UserID     uuid.UUID          `json:"user_id"`
	NumTracks  int32              `json:"num_tracks"`
	Type       PlaylistType       `json:"type"`
	Name       string             `json:"name"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Visibility PlaylistVisibility `json:"visibility"`
	Year       int32              `json:"year"`
	Week       pgtype.Timestamptz `json:"week"`
	Month      pgtype.Int4        `json:"month"`
}

func (q *Queries) GetUserPlaylists(ctx context.Context, arg GetUserPlaylistsParams) ([]GetUserPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getUserPlaylists, arg.UserID, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPlaylistsRow
	for rows.Next() {
		var i GetUserPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NumTracks,
			&i.Type,
			&i.Name,
			&i.CreatedAt,
			&i.Visibility,
			&i.Year,
			&i.Week,
			&i.Month,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriendsByID = `-- name: ListFriendsByID :many
SELECT u.id, u.display_name, u.username, u.image_url, u.email, u.registered_at, u.role, u.password, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM friendships f
JOIN users u
  ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
  AND f.status = 'accepted'
`

func (q *Queries) ListFriendsByID(ctx context.Context, userAID uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listFriendsByID, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Username,
			&i.ImageUrl,
			&i.Email,
			&i.RegisteredAt,
			&i.Role,
			&i.Password,
			&i.SpotifyUserID,
			&i.SpotifyUserData,
			&i.CreatedAt,
			&i.RefreshToken,
			&i.RefreshExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriendsByUsername = `-- name: ListFriendsByUsername :many
SELECT friend.id, friend.display_name, friend.username, friend.image_url, friend.email, friend.registered_at, friend.role, friend.password, friend.spotify_user_id, friend.spotify_user_data, friend.created_at, friend.refresh_token, friend.refresh_expires_at
FROM users AS me
  JOIN friendships AS f
    ON me.id IN (f.user_a_id, f.user_b_id)
  JOIN users AS friend
    ON friend.id = CASE
         WHEN me.id = f.user_a_id THEN f.user_b_id
         ELSE f.user_a_id
       END
WHERE
  me.username = $1
  AND f.status = 'accepted'
`

func (q *Queries) ListFriendsByUsername(ctx context.Context, username pgtype.Text) ([]User, error) {
	rows, err := q.db.Query(ctx, listFriendsByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Username,
			&i.ImageUrl,
			&i.Email,
			&i.RegisteredAt,
			&i.Role,
			&i.Password,
			&i.SpotifyUserID,
			&i.SpotifyUserData,
			&i.CreatedAt,
			&i.RefreshToken,
			&i.RefreshExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomingRequests = `-- name: ListIncomingRequests :many
SELECT u.id, u.display_name, u.username, u.image_url, u.email, u.registered_at, u.role, u.password, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at, f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.requester_id <> $1
AND f.status = 'pending'
`

type ListIncomingRequestsRow struct {
	User       User       `json:"user"`
	Friendship Friendship `json:"friendship"`
}

func (q *Queries) ListIncomingRequests(ctx context.Context, userAID uuid.UUID) ([]ListIncomingRequestsRow, error) {
	rows, err := q.db.Query(ctx, listIncomingRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIncomingRequestsRow
	for rows.Next() {
		var i ListIncomingRequestsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.ImageUrl,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.Password,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.Friendship.UserAID,
			&i.Friendship.UserBID,
			&i.Friendship.RequesterID,
			&i.Friendship.Status,
			&i.Friendship.RequestedAt,
			&i.Friendship.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutgoingRequests = `-- name: ListOutgoingRequests :many
SELECT u.id, u.display_name, u.username, u.image_url, u.email, u.registered_at, u.role, u.password, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at, f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.requester_id = $1
AND f.status = 'pending'
`

type ListOutgoingRequestsRow struct {
	User       User       `json:"user"`
	Friendship Friendship `json:"friendship"`
}

func (q *Queries) ListOutgoingRequests(ctx context.Context, userAID uuid.UUID) ([]ListOutgoingRequestsRow, error) {
	rows, err := q.db.Query(ctx, listOutgoingRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOutgoingRequestsRow
	for rows.Next() {
		var i ListOutgoingRequestsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.ImageUrl,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.Password,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.Friendship.UserAID,
			&i.Friendship.UserBID,
			&i.Friendship.RequesterID,
			&i.Friendship.Status,
			&i.Friendship.RequestedAt,
			&i.Friendship.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequests = `-- name: ListRequests :many
SELECT
    u.id, u.display_name, u.username, u.image_url, u.email, u.registered_at, u.role, u.password, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at,
    f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.status = 'pending'
`

type ListRequestsRow struct {
	User       User       `json:"user"`
	Friendship Friendship `json:"friendship"`
}

func (q *Queries) ListRequests(ctx context.Context, userAID uuid.UUID) ([]ListRequestsRow, error) {
	rows, err := q.db.Query(ctx, listRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRequestsRow
	for rows.Next() {
		var i ListRequestsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.ImageUrl,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.Password,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.Friendship.UserAID,
			&i.Friendship.UserBID,
			&i.Friendship.RequesterID,
			&i.Friendship.Status,
			&i.Friendship.RequestedAt,
			&i.Friendship.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFriendship = `-- name: RemoveFriendship :execrows
DELETE FROM friendships
    WHERE user_a_id = LEAST($1::uuid, $2::uuid) AND user_b_id = GREATEST($1::uuid, $2::uuid)
`

type RemoveFriendshipParams struct {
	UserAID uuid.UUID `json:"user_a_id"`
	UserBID uuid.UUID `json:"user_b_id"`
}

func (q *Queries) RemoveFriendship(ctx context.Context, arg RemoveFriendshipParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeFriendship, arg.UserAID, arg.UserBID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT
    u.id, u.display_name, u.username, u.image_url, u.email, u.registered_at, u.role, u.password, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at,
    f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM users u
LEFT JOIN friendships f
  ON f.user_a_id = LEAST($1::uuid,  u.id)
 AND f.user_b_id = GREATEST($1::uuid, u.id)
WHERE
  similarity(u.username, $2::text) > 0.2
  AND $1::uuid <> u.id
  AND (f.status IS NULL OR f.status <> 'blocked')
ORDER BY similarity(u.username, $2::text) DESC
LIMIT 10
`

type SearchUsersParams struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
}

type SearchUsersRow struct {
	User        User                 `json:"user"`
	UserAID     uuid.UUID            `json:"user_a_id"`
	UserBID     uuid.UUID            `json:"user_b_id"`
	RequesterID uuid.UUID            `json:"requester_id"`
	Status      NullFriendshipStatus `json:"status"`
	RequestedAt pgtype.Timestamptz   `json:"requested_at"`
	RespondedAt pgtype.Timestamptz   `json:"responded_at"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := q.db.Query(ctx, searchUsers, arg.ID, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersRow
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.DisplayName,
			&i.User.Username,
			&i.User.ImageUrl,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.Password,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.UserAID,
			&i.UserBID,
			&i.RequesterID,
			&i.Status,
			&i.RequestedAt,
			&i.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signUpUser = `-- name: SignUpUser :one
UPDATE users
SET username = $1, display_name = $2, registered_at = now()
WHERE id = $3
RETURNING id, display_name, username, image_url, email, registered_at, role, password, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at
`

type SignUpUserParams struct {
	Username    pgtype.Text `json:"username"`
	DisplayName pgtype.Text `json:"display_name"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) SignUpUser(ctx context.Context, arg SignUpUserParams) (User, error) {
	row := q.db.QueryRow(ctx, signUpUser, arg.Username, arg.DisplayName, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.ImageUrl,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.Password,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const updateSpotifyTokens = `-- name: UpdateSpotifyTokens :exec
UPDATE spotify_tokens s
SET
  access_token = $1,
  refresh_token = $2,
  scope = $3,
  token_expires = $4
FROM users u
WHERE u.id = $5
`

type UpdateSpotifyTokensParams struct {
	AccessToken  string             `json:"access_token"`
	RefreshToken string             `json:"refresh_token"`
	Scope        string             `json:"scope"`
	TokenExpires pgtype.Timestamptz `json:"token_expires"`
	ID           uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateSpotifyTokens(ctx context.Context, arg UpdateSpotifyTokensParams) error {
	_, err := q.db.Exec(ctx, updateSpotifyTokens,
		arg.AccessToken,
		arg.RefreshToken,
		arg.Scope,
		arg.TokenExpires,
		arg.ID,
	)
	return err
}

const updateUserImage = `-- name: UpdateUserImage :execrows
UPDATE users
SET image_url = $1
WHERE id = $2
`

type UpdateUserImageParams struct {
	ImageUrl pgtype.Text `json:"image_url"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateUserImage(ctx context.Context, arg UpdateUserImageParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateUserImage, arg.ImageUrl, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users
SET
  username = COALESCE($1, username),
  display_name = COALESCE($2, display_name),
  email = COALESCE($4, email)
WHERE id = $3
RETURNING id, display_name, username, image_url, email, registered_at, role, password, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at
`

type UpdateUserProfileParams struct {
	Username    pgtype.Text `json:"username"`
	DisplayName pgtype.Text `json:"display_name"`
	ID          uuid.UUID   `json:"id"`
	Email       pgtype.Text `json:"email"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.Username,
		arg.DisplayName,
		arg.ID,
		arg.Email,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Username,
		&i.ImageUrl,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.Password,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const updateVisibility = `-- name: UpdateVisibility :execrows
UPDATE playlists
    SET visibility = $1
    WHERE id = $2 AND user_id = $3
`

type UpdateVisibilityParams struct {
	Visibility PlaylistVisibility `json:"visibility"`
	ID         uuid.UUID          `json:"id"`
	UserID     uuid.UUID          `json:"user_id"`
}

func (q *Queries) UpdateVisibility(ctx context.Context, arg UpdateVisibilityParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateVisibility, arg.Visibility, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertSpotifyCredentials = `-- name: UpsertSpotifyCredentials :exec
INSERT INTO spotify_tokens (
  user_id,
  access_token,
  token_type,
  scope,
  refresh_token,
  token_expires
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
)
ON CONFLICT (user_id)
DO UPDATE SET
  access_token   = EXCLUDED.access_token,
  token_type     = EXCLUDED.token_type,
  scope          = EXCLUDED.scope,
  refresh_token  = EXCLUDED.refresh_token,
  token_expires = EXCLUDED.token_expires
`

type UpsertSpotifyCredentialsParams struct {
	UserID       string             `json:"user_id"`
	AccessToken  string             `json:"access_token"`
	TokenType    string             `json:"token_type"`
	Scope        string             `json:"scope"`
	RefreshToken string             `json:"refresh_token"`
	TokenExpires pgtype.Timestamptz `json:"token_expires"`
}

func (q *Queries) UpsertSpotifyCredentials(ctx context.Context, arg UpsertSpotifyCredentialsParams) error {
	_, err := q.db.Exec(ctx, upsertSpotifyCredentials,
		arg.UserID,
		arg.AccessToken,
		arg.TokenType,
		arg.Scope,
		arg.RefreshToken,
		arg.TokenExpires,
	)
	return err
}
