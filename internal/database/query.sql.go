// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :execrows
UPDATE friendships
    SET
        status = 'accepted',
        responded_at = NOW()
    WHERE
        status = 'pending' AND
        user_a_id = LEAST($1::uuid, $2::uuid) AND
        user_b_id = GREATEST($1::uuid, $2::uuid) AND
        requester_id <> $1::uuid
`

type AcceptFriendRequestParams struct {
	Responder uuid.UUID
	Respondee uuid.UUID
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, arg AcceptFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, acceptFriendRequest, arg.Responder, arg.Respondee)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const cancelFriendRequest = `-- name: CancelFriendRequest :execrows
DELETE FROM friendships
    WHERE user_a_id = LEAST($1::uuid, $2::uuid) AND user_b_id = GREATEST($1::uuid, $2::uuid)
    AND status = 'pending'
    AND requester_id = $3::uuid
`

type CancelFriendRequestParams struct {
	UserAID     uuid.UUID
	UserBID     uuid.UUID
	RequesterID uuid.UUID
}

func (q *Queries) CancelFriendRequest(ctx context.Context, arg CancelFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, cancelFriendRequest, arg.UserAID, arg.UserBID, arg.RequesterID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createFriendRequest = `-- name: CreateFriendRequest :execrows
INSERT INTO friendships (
  user_a_id,
  user_b_id,
  requester_id,
  status,
  requested_at,
  responded_at
)
VALUES (
  LEAST($1::uuid, $2::uuid),
  GREATEST($1::uuid, $2::uuid),
  $1::uuid,
  'pending',
  now(),
  NULL
)
ON CONFLICT (user_a_id, user_b_id)
DO UPDATE
  SET
    status       = 'pending',
    requested_at = now(),
    requester_id = EXCLUDED.requester_id,
    responded_at = NULL
  WHERE friendships.status = 'rejected'
`

type CreateFriendRequestParams struct {
	Requester uuid.UUID
	Requestee uuid.UUID
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, createFriendRequest, arg.Requester, arg.Requestee)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createMonthlyPlaylist = `-- name: CreateMonthlyPlaylist :one
INSERT INTO monthly_playlists(user_id, tracks, year, month, name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateMonthlyPlaylistParams struct {
	UserID uuid.UUID
	Tracks [][]byte
	Year   int16
	Month  int16
	Name   string
}

func (q *Queries) CreateMonthlyPlaylist(ctx context.Context, arg CreateMonthlyPlaylistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createMonthlyPlaylist,
		arg.UserID,
		arg.Tracks,
		arg.Year,
		arg.Month,
		arg.Name,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createSpotifyUser = `-- name: CreateSpotifyUser :one
INSERT INTO users (spotify_user_id, email, spotify_user_data)
VALUES ($1, $2, $3)
ON CONFLICT (spotify_user_id) DO UPDATE
SET email = users.email -- no op
RETURNING id, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at
`

type CreateSpotifyUserParams struct {
	SpotifyUserID   string
	Email           string
	SpotifyUserData []byte
}

func (q *Queries) CreateSpotifyUser(ctx context.Context, arg CreateSpotifyUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createSpotifyUser, arg.SpotifyUserID, arg.Email, arg.SpotifyUserData)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getLatestPrivateKey = `-- name: GetLatestPrivateKey :one
SELECT kid, value FROM private_keys
ORDER BY kid DESC
LIMIT 1
`

func (q *Queries) GetLatestPrivateKey(ctx context.Context) (PrivateKey, error) {
	row := q.db.QueryRow(ctx, getLatestPrivateKey)
	var i PrivateKey
	err := row.Scan(&i.Kid, &i.Value)
	return i, err
}

const getPlaylist = `-- name: GetPlaylist :one
SELECT id, user_id, tracks, year, month, name, created_at, visibility FROM monthly_playlists WHERE id = $1
`

func (q *Queries) GetPlaylist(ctx context.Context, id uuid.UUID) (MonthlyPlaylist, error) {
	row := q.db.QueryRow(ctx, getPlaylist, id)
	var i MonthlyPlaylist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Tracks,
		&i.Year,
		&i.Month,
		&i.Name,
		&i.CreatedAt,
		&i.Visibility,
	)
	return i, err
}

const getPrivateKey = `-- name: GetPrivateKey :one
SELECT value FROM private_keys WHERE kid = $1
`

func (q *Queries) GetPrivateKey(ctx context.Context, kid int32) (string, error) {
	row := q.db.QueryRow(ctx, getPrivateKey, kid)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getUserBySpotifyId = `-- name: GetUserBySpotifyId :one
SELECT id, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE spotify_user_id = $1
`

func (q *Queries) GetUserBySpotifyId(ctx context.Context, spotifyUserID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserBySpotifyId, spotifyUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserFromSession = `-- name: GetUserFromSession :one
SELECT id, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at FROM users WHERE refresh_token = $1
`

func (q *Queries) GetUserFromSession(ctx context.Context, refreshToken uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserFromSession, refreshToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const getUserPlaylists = `-- name: GetUserPlaylists :many
SELECT id, user_id, tracks, year, month, name, created_at, visibility FROM monthly_playlists WHERE user_id = $1
`

func (q *Queries) GetUserPlaylists(ctx context.Context, userID uuid.UUID) ([]MonthlyPlaylist, error) {
	rows, err := q.db.Query(ctx, getUserPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonthlyPlaylist
	for rows.Next() {
		var i MonthlyPlaylist
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tracks,
			&i.Year,
			&i.Month,
			&i.Name,
			&i.CreatedAt,
			&i.Visibility,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriends = `-- name: ListFriends :many
SELECT u.id, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at
FROM friendships f
JOIN users u
  ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
  AND f.status = 'accepted'
`

func (q *Queries) ListFriends(ctx context.Context, userAID uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listFriends, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.RegisteredAt,
			&i.Role,
			&i.SpotifyUserID,
			&i.SpotifyUserData,
			&i.CreatedAt,
			&i.RefreshToken,
			&i.RefreshExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomingRequests = `-- name: ListIncomingRequests :many
SELECT u.id, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at, f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.requester_id <> $1
AND f.status = 'pending'
`

type ListIncomingRequestsRow struct {
	User       User
	Friendship Friendship
}

func (q *Queries) ListIncomingRequests(ctx context.Context, userAID uuid.UUID) ([]ListIncomingRequestsRow, error) {
	rows, err := q.db.Query(ctx, listIncomingRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIncomingRequestsRow
	for rows.Next() {
		var i ListIncomingRequestsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Username,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.Friendship.UserAID,
			&i.Friendship.UserBID,
			&i.Friendship.RequesterID,
			&i.Friendship.Status,
			&i.Friendship.RequestedAt,
			&i.Friendship.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutgoingRequests = `-- name: ListOutgoingRequests :many
SELECT u.id, u.username, u.email, u.registered_at, u.role, u.spotify_user_id, u.spotify_user_data, u.created_at, u.refresh_token, u.refresh_expires_at, f.user_a_id, f.user_b_id, f.requester_id, f.status, f.requested_at, f.responded_at
FROM friendships f
JOIN users u
ON (u.id = CASE
        WHEN f.user_a_id = $1 THEN f.user_b_id
        ELSE f.user_a_id
    END)
WHERE (f.user_a_id = LEAST($1, u.id) AND f.user_b_id = GREATEST($1, u.id))
AND f.requester_id = $1
AND f.status = 'pending'
`

type ListOutgoingRequestsRow struct {
	User       User
	Friendship Friendship
}

func (q *Queries) ListOutgoingRequests(ctx context.Context, userAID uuid.UUID) ([]ListOutgoingRequestsRow, error) {
	rows, err := q.db.Query(ctx, listOutgoingRequests, userAID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOutgoingRequestsRow
	for rows.Next() {
		var i ListOutgoingRequestsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Username,
			&i.User.Email,
			&i.User.RegisteredAt,
			&i.User.Role,
			&i.User.SpotifyUserID,
			&i.User.SpotifyUserData,
			&i.User.CreatedAt,
			&i.User.RefreshToken,
			&i.User.RefreshExpiresAt,
			&i.Friendship.UserAID,
			&i.Friendship.UserBID,
			&i.Friendship.RequesterID,
			&i.Friendship.Status,
			&i.Friendship.RequestedAt,
			&i.Friendship.RespondedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectFriendRequest = `-- name: RejectFriendRequest :execrows
UPDATE friendships
    SET
        status = 'rejected',
        responded_at = NOW()
    WHERE
        status = 'pending' AND
        user_a_id = LEAST($1::uuid, $2::uuid) AND
        user_b_id = GREATEST($1::uuid, $2::uuid) AND
        requester_id <> $1::uuid
`

type RejectFriendRequestParams struct {
	Responder uuid.UUID
	Respondee uuid.UUID
}

func (q *Queries) RejectFriendRequest(ctx context.Context, arg RejectFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, rejectFriendRequest, arg.Responder, arg.Respondee)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeFriendship = `-- name: RemoveFriendship :execrows
DELETE FROM friendships
    WHERE user_a_id = LEAST($1::uuid, $2::uuid) AND user_b_id = GREATEST($1::uuid, $2::uuid)
`

type RemoveFriendshipParams struct {
	UserAID uuid.UUID
	UserBID uuid.UUID
}

func (q *Queries) RemoveFriendship(ctx context.Context, arg RemoveFriendshipParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeFriendship, arg.UserAID, arg.UserBID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const signUpUser = `-- name: SignUpUser :one
UPDATE users
SET username = $1, registered_at = now()
WHERE id = $2 AND registered_at IS NULL
RETURNING id, username, email, registered_at, role, spotify_user_id, spotify_user_data, created_at, refresh_token, refresh_expires_at
`

type SignUpUserParams struct {
	Username pgtype.Text
	ID       uuid.UUID
}

func (q *Queries) SignUpUser(ctx context.Context, arg SignUpUserParams) (User, error) {
	row := q.db.QueryRow(ctx, signUpUser, arg.Username, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.RegisteredAt,
		&i.Role,
		&i.SpotifyUserID,
		&i.SpotifyUserData,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshExpiresAt,
	)
	return i, err
}

const updateVisibility = `-- name: UpdateVisibility :execrows
UPDATE monthly_playlists
    SET visibility = $1
    WHERE id = $2 AND user_id = $3
`

type UpdateVisibilityParams struct {
	Visibility PlaylistVisibility
	ID         uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) UpdateVisibility(ctx context.Context, arg UpdateVisibilityParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateVisibility, arg.Visibility, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertSpotifyCredentials = `-- name: UpsertSpotifyCredentials :exec
INSERT INTO spotify_tokens (
  user_id,
  access_token,
  token_type,
  scope,
  refresh_token
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
ON CONFLICT (user_id)
DO UPDATE SET
  access_token   = EXCLUDED.access_token,
  token_type     = EXCLUDED.token_type,
  scope          = EXCLUDED.scope,
  refresh_token  = EXCLUDED.refresh_token
`

type UpsertSpotifyCredentialsParams struct {
	UserID       string
	AccessToken  string
	TokenType    string
	Scope        string
	RefreshToken string
}

func (q *Queries) UpsertSpotifyCredentials(ctx context.Context, arg UpsertSpotifyCredentialsParams) error {
	_, err := q.db.Exec(ctx, upsertSpotifyCredentials,
		arg.UserID,
		arg.AccessToken,
		arg.TokenType,
		arg.Scope,
		arg.RefreshToken,
	)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (spotify_user_id, email, spotify_user_data)
VALUES ($1, $2, $3)
ON CONFLICT (spotify_user_id)
  DO UPDATE SET
    email  = EXCLUDED.email,
    spotify_user_data = EXCLUDED.spotify_user_data
RETURNING id, refresh_token
`

type UpsertUserParams struct {
	SpotifyUserID   string
	Email           string
	SpotifyUserData []byte
}

type UpsertUserRow struct {
	ID           uuid.UUID
	RefreshToken uuid.UUID
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (UpsertUserRow, error) {
	row := q.db.QueryRow(ctx, upsertUser, arg.SpotifyUserID, arg.Email, arg.SpotifyUserData)
	var i UpsertUserRow
	err := row.Scan(&i.ID, &i.RefreshToken)
	return i, err
}
